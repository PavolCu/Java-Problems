<h2>Manipulating fields and methods</h2>
<div class="step-text">
<p>For now, you must already have a basic understanding of the <a class="theory-lookup" href="/learn/step/3609" rel="noopener noreferrer nofollow" target="_blank" title="In Java, reflection is a powerful feature that allows a programmer to examine or modify the structure of a class at runtime. | It enables a program to inspect and manipulate its own code, making it a useful tool for runtime code generation, testing, and more. With reflection, you can access implementation details, such as a class's member fields, even if they are not exposed by its public API, which can potentially bypass encapsulation. Reflection is implemented in Java through the `java.lang.reflect` package, which includes classes, interfaces, and exceptions. Reflection provides type information and can reveal methods generated by the compiler, such as bridge methods. However, due to the risks associated with reflection, it is recommended to limit its use to specific, well-defined areas of the code, ideally within frameworks and libraries, where it can provide a high level of abstraction and make the code more flexible and reusable. The Java reflection process involves three steps:

1. Obtain the object of the class you want to reflect on. 2. Get the attribute of the class you want to reflect on as a list or array using a method. 3.">reflection</a>. However, what we did in the previous topics was just a small part of what is possible. In this topic, we will learn how to get fields and their values, write data into fields and call methods by using reflection.</p>
<h5 id="getting-fields-values">Getting fields values</h5>
<p>We will start by explaining how to get the values of particular fields. Let's revise such a class:</p>
<pre><code class="language-java">class Item {
    public static final int maxItems = 100;
    public static int inStock = 19;

    private String name;
    protected int basePrice;

    public Item(String name, int basePrice) {
        this.name = name;
        this.basePrice = basePrice;
    }

    public String getName() {
        return name;
    }

    public int getPrice() {
        return (int) (basePrice * getMarkUp());
    }

    protected double getMarkUp() {
        double markUp = 0.1;
        // ... connecting to the remote server
        return 1 + markUp;
    }
}</code></pre>
<p>With the help of the <code class="language-java">Field</code> <a class="theory-lookup" href="/learn/step/4727" rel="noopener noreferrer nofollow" target="_blank" title="In Java, an object is an instance of a particular class that defines its properties and possible behaviors. | Each object has its own state, separated from other objects, and is accessed using a reference, which stores the memory address where the actual object is located. Objects from the standard library, such as String and Date, as well as programmer-defined classes, are all reference types. The new keyword is used to create an object of a particular class. For example, String str = new String(hello); creates a new String object with the value hello. Objects have a unique identity, can be managed, and have a human-readable representation.">object</a> we can find out the value of some field of the object. Basically, this is the main purpose of this <a class="theory-lookup" href="/learn/step/19918" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a class is one of the fundamental concepts used to develop the logic of a program. | It is a template that defines properties and behaviors of objects. Fields in a class describe the properties of an object, while methods describe what an object can do. Classes can be divided into two groups: instance and static. Instance methods are unique to each instance of a class and can access and modify the state of that instance. Custom classes can be created to define fields and methods that are tailored to specific purposes.">class</a>. It has a <code class="language-java">get</code> method that takes one <a class="theory-lookup" href="/learn/step/12877" rel="noopener noreferrer nofollow" target="_blank" title="In Java, an argument, in the context of testing, refers to the input value or values provided to a test method. | These arguments can be a single value or a sequence of values, which can be of various types such as primitives, strings, arrays, collections, etc. Argument sources are used to supply these values, which can be a sequence of literal values, command-line arguments, or an array or stream of arguments generated by a method. When a test method has multiple parameters, the argument source method must return a collection, stream, or array of arrays of the appropriate type.">argument</a>, which is an object whose field's value we want to get. Note that the <code class="language-java">Field</code> object is not bound to any object of the <code class="language-java">Item</code> class. That's why we need to pass the object directly as an argument. To get the value of the <a class="theory-lookup" href="/learn/step/3534" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a static field is a field declared with the `static` keyword that is shared by all objects of a class, rather than belonging to an individual instance. | It can hold any primitive or reference type, and all instances of the class share the same value for a static field. Static fields are useful for storing global variables that all instances of a class should share, as they help save memory by not creating separate copies for each instance. However, it's typically not recommended to declare non-final public static fields, as they can be accessed and modified by any code that has access to the class. Additionally, it's important to note that static fields cannot access instance fields or methods, as there is no instance context.">static field</a> you can pass <code class="language-java">null</code> as an argument.</p>
<p>Let's try to output the values of all fields of an <code class="language-java">Item</code> object. At first, we create an object and get a <code class="language-java">Class</code> object for it.</p>
<pre><code class="language-java">Item item = new Item("apples", 500);
Class itemClass = item.getClass();
Field[] fields = itemClass.getDeclaredFields();
</code></pre>
<p>Now let's try to use the <code class="language-java">get</code> method for all its fields:</p>
<pre><code class="language-java">for (Field field : fields) {
    System.out.println(field.getName() + " " + field.get(item));
}</code></pre>
<p>And we get...   </p>
<pre><code class="language-no-highlight">java.lang.IllegalAccessException: cannot access a member with modifiers "private"</code></pre>
<p>Oops. Java is definitely right, you can't <a class="theory-lookup" href="/learn/step/3589" rel="noopener noreferrer nofollow" target="_blank" title="In Java, access modifiers are keywords used to determine who can access the code, specifically fields, methods, and classes. | There are four access modifiers in Java: private, protected, default (no keywords), and public. These modifiers are used to ensure the clarity and safety of the code by controlling who can access the code. The private modifier restricts access to the class itself, while the protected modifier allows access to classes in the same package and any extending class. The default modifier, also known as package-private, allows access to classes in the same package. The public modifier allows access from anywhere.">access</a> <a class="theory-lookup" href="/learn/step/3599" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a private field is a field that is declared with the access modifier 'private', which restricts access to that field to the class in which it is declared. | This means that other classes, even if they are in the same package, cannot directly access or modify the private field of the class. By using the private access modifier, you can encapsulate the implementation details of a class and provide a controlled interface for other classes to interact with it. Private fields are typically not exposed directly to other classes. Instead, they are made accessible through accessor methods, also known as getter and setter methods. These methods provide encapsulation, which allows you to hide implementation details and control data access, ensuring security. According to the data encapsulation principle, the field of a class should not be directly accessed from other classes. Instead, the field can be accessed only through the methods of that particular class. To access a hidden field, programmers write special types of methods called getters and setters. Getters can only read the field, and setters can only write to the field. For example, a class may have four fields, each of which is declared as private to hide the field from direct access from other classes. The class may also have public getters and setters for accessing the fields through these methods.">private fields</a>. Luckily, there's a very simple way around. Java checks if you can access this field, but you can change the accessibility just by calling <code class="language-java">setAccessible(true)</code> method.</p>
<p>Let's improve the code a little:</p>
<pre><code class="language-java">for (Field field : fields) {
    field.setAccessible(true);
    System.out.println(field.getName() + " " + field.get(item));
}</code></pre>
<p>And now we've got what we expected:</p>
<pre><code class="language-no-highlight">maxItems 100
inStock 19
name apples
basePrice 500</code></pre>
<h5 id="setting-values-to-the-fields">Setting values to the fields</h5>
<p><code class="language-java">Field</code>'s <code class="language-java">set</code> method works the same way. It takes two arguments: an object and a new value for the field. Again, if you want to set a static field you can pass <code class="language-java">null</code> as the first argument. Below is an example of calling the <code class="language-java">set</code> method. What we try to do here is to set the value to itself:</p>
<pre><code class="language-java">for (Field field : fields) {
    field.setAccessible(true);
    field.set(item, field.get(item));
    System.out.println(field.getName() + " " + field.get(item));
}</code></pre>
<p>And there is another exception...</p>
<pre><code class="language-no-highlight">java.lang.IllegalAccessException: Can not set static final int field to java.lang.Integer</code></pre>
<p>The <code class="language-java">final</code> fields in Java cannot be changed, it is true. But now there is no workaround for this: it would be an even bigger crime in the world of Java if someone changed a <a class="theory-lookup" href="/learn/step/7427" rel="noopener noreferrer nofollow" target="_blank" title="In Java, final is a keyword used to denote immutability and consistency in programming. | It can be used in various contexts such as class, method, variable, and parameter declarations, each with specific behaviors and implications. When used with variables, final ensures that the value of the variable remains constant throughout the execution of the program. Once a value is assigned to a final variable, it cannot be modified. However, it can be accessed multiple times as needed. If a final variable is not assigned a value before using it, the compiler will produce an error.">final</a> field of an object. </p>
<p>To correct the code, we should make sure that the field is not final by checking its modifier with <code class="language-java">isFinal()</code> method. Since the example above is somewhat useless, we'll also make it more sensible:</p>
<pre><code class="language-java">for (Field field : fields) {
    field.setAccessible(true);
    if (field.getType() == int.class &amp;&amp; !Modifier.isFinal(field.getModifiers())) {
        field.set(item, 0);
    }
}</code></pre>
<p>This code resets all non-final integer fields in the instance of some class to 0. </p>
<h5 id="invoking-methods">Invoking methods</h5>
<p><a class="theory-lookup" href="/learn/step/10973" rel="noopener noreferrer nofollow" target="_blank" title="In Java, invoking a method refers to the act of executing a method's code by calling it from another part of the program. | When a method is invoked, a new stack frame is created in the program's execution stack to store the method's parameters, local variables, and return address. The method's parameters are passed to the stack frame, and the method's code is executed. Once the method's code has completed execution, the stack frame is removed from the stack, and control is returned to the point in the program from which the method was invoked.">Invoking methods</a> is similar, but this time the <code class="language-java">invoke</code> method of the <code class="language-java">Method</code> object is used. This method can take a different number of arguments: one more than the <a class="theory-lookup" href="/learn/step/10973" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a call refers to the act of instructing the program to execute a specific set of code within a method. | It involves using the method's name and providing the necessary arguments. The method called (or invoked) depends on the passed parameters. If different values are passed to it, the result of the program will also change. However, when calling a function, you should always provide the correct number and type of arguments that the function expects. For instance, if there is another method that takes a student's name, age, and average score as parameters and prints them, the call to this method will depend on the provided parameters. If the application does not throw an exception, a stack trace message will not be displayed. However, a stack trace can be obtained at any specific point by calling the appropriate method, which will return an array.">called</a> method has. The first argument is the object whose method we want to call or, as you might expect, in case of <a class="theory-lookup" href="/learn/step/3534" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a static method is a method that is associated with a class rather than an instance of a class. | It can be accessed directly using the class name and does not require the creation of a class instance. A static method can only access static fields and other static methods within the same class, and cannot refer to the `this` keyword because there is no instance context. Static methods are often used as utility methods that provide common functionality for the entire project. They can be called from instance methods, but not the other way around.">static methods</a> it's <code class="language-java">null</code>. Take a look at the example:</p>
<pre><code class="language-java">Method[] methods = itemClass.getDeclaredMethods();
for (Method method : methods) {
    method.setAccessible(true);
    System.out.println(method.invoke(item));
}</code></pre>
<p>All three methods had zero arguments, so <code class="language-java">invoke</code> was called with only one argument. The output may differ because the elements in the returned array are not sorted and are not in any particular order. Here's one of the possible outputs:</p>
<pre><code class="language-no-highlight">apples
1.1
550</code></pre>
<p> </p>
<p>If you want to invoke a static method, you need to pass the class to the <code class="language-java">invoke</code> method: <code class="language-java">method.invoke(YourClass.class, ...)</code>.</p>
<p> </p>
<h5 id="when-it-works">When it works</h5>
<p>We have covered a way of accessing information about methods and fields at runtime via reflection. After reading that you may have a question: why do you need to get methods and fields of a class while executing the program if you know all of them at the moment of compiling a program?</p>
<p>One of the typical problems that can be solved by using reflection is the <strong>serialization</strong> of objects. If some class does not <a class="theory-lookup" href="/learn/step/3556" rel="noopener noreferrer nofollow" target="_blank" title="In Java, an interface is a special type of class that primarily declares functionality. | It contains abstract methods, which are methods without a body, and constants. Interfaces are used to establish a contract for what a class can do, without specifying how the class should do it. This allows for greater flexibility and modularity in programming, as it enables the implementation of multiple inheritances and promotes loose coupling between objects. When a class implements an interface, it agrees to provide the implementation for all the methods declared in the interface.">implement</a> the <code class="language-java">Serializable</code> <a class="theory-lookup" href="/learn/step/3615" rel="noopener noreferrer nofollow" target="_blank" title="In Java, an interface is a reference type that contains method declarations and serves as a literal interface between a class inheriting that interface and another class. | Unlike a class, an interface can extend multiple interfaces, and a class can implement multiple interfaces. Interfaces help to abstract from specific classes and emphasize functionality, making software design more reusable and clean. They cannot be instantiated, and the main idea of an interface is declaring functionality. Interfaces are a special kind of class that represents a map (or dictionary) for storing key-value pairs where the type of the key and the type of the stored value are specified. A real-world example of a map is a phone book where keys are the names of your friends, and values are their phone numbers. The Map interface is not a subtype of the Collection interface, but maps are often considered a collection since they are part of the collection framework and have similar methods.">interface</a>, it cannot be serialized without using reflection. With reflection, however, all the class fields, even private ones, become visible, so you can write them into an external file. When deserializing, you can read this file and restore all the fields, including private, in it. <strong>Never change the values of private fields in all cases except for <a class="theory-lookup" href="/learn/step/8147" rel="noopener noreferrer nofollow" target="_blank" title="In Java, deserialization is the reverse process of serialization. | While serialization is the process of converting the state of an object into a stream of bytes to store the data in a file or a database, deserialization is the process of reconstructing the actual object from the serialized byte form. The Java platform provides a default binary serialization protocol for serializing and deserializing Java objects into binary format. During deserialization, an instance of the object is created first, and then the fields, including private ones, are restored from the external file. It is essential to never change the value of private fields during deserialization, except for deserialization, as it may cause the program to crash. Custom serialization can be used to validate fields during deserialization and handle any design constraints that may arise in future releases.">deserialization</a></strong>, because this way there is a high probability to crash the program. To deserialize an object, you must first create an instance of it. You will learn how to do this in the following topics.</p>
</div>
