<h2>Command</h2>
<div class="step-text">
<p>You have probably heard of <strong><a class="theory-lookup" href="/learn/step/5519" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a behavioral pattern is a design pattern that is concerned with the interaction between objects. | There are about 12 design patterns that belong to this category, with the command pattern being one of the most commonly used. The purpose of the command pattern is to decouple the logic between a command and its consumer. It encapsulates all the data related to a command in one object, which typically consists of a set of methods, their parameters, and one or more objects that these methods belong to. This decoupling allows for flexibility, as changing a command does not affect its consumer. Other behavioral patterns include the state pattern, which is useful when the behavior of a class depends on its current state and changes during runtime.">behavioral patterns</a></strong> by now. These are the type of patterns concerned with the interaction of objects. While there are about 12 <a class="theory-lookup" href="/learn/step/19054" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a design pattern is a reusable solution to a common problem that occurs in software design. | It provides a general template for how to solve a problem, rather than a specific implementation. The Strategy pattern, for example, is a behavioral design pattern that defines a family of algorithms, encapsulates each one in a separate class, and makes them interchangeable within that family. This allows for easier addition of new algorithms and more concise code, by moving algorithm execution into their own classes. The Command pattern, another behavioral design pattern, decouples the logic between a command and its consumer by encapsulating all the data related to a command in one object.">design patterns</a> that belong to behavioral patterns, the <strong><a class="theory-lookup" href="/learn/step/19054" rel="noopener noreferrer nofollow" target="_blank" title="In Java, the Command Pattern is a behavioral pattern that decouples the object that invokes an operation from the one that knows how to perform it. | It encapsulates all the data related to a command in one object, known as a Command interface. This interface contains a set of methods, their parameters, and the objects that these methods belong to. The main advantage of the Command Pattern is that it decouples the object that invokes the operation from the one that knows how to perform it, allowing for greater flexibility and maintainability. It is commonly used in GUI buttons and menu items, networking, and transactional behavior, and can be used to implement undo functionality and create macro commands.">command pattern</a> </strong>has a special place among them as it's the most commonly used. The purpose of the command pattern is to <strong>decouple </strong>the logic between a command and its consumers.</p>
<p>In a nutshell, a command pattern encapsulates<strong> </strong>all the data related to a command in one <a class="theory-lookup" href="/learn/step/4727" rel="noopener noreferrer nofollow" target="_blank" title="In Java, an object is an instance of a particular class that defines its properties and possible behaviors. | Each object has its own state, separated from other objects, and is accessed using a reference, which stores the memory address where the actual object is located. Objects from the standard library, such as String and Date, as well as programmer-defined classes, are all reference types. The new keyword is used to create an object of a particular class. For example, String str = new String(hello); creates a new String object with the value hello. Objects have a unique identity, can be managed, and have a human-readable representation.">object</a>. Usually, this data consists of a <a class="theory-lookup" href="/learn/step/3575" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a set is a collection of unique elements, similar to a mathematical set. | It is fundamentally different from arrays or lists because it is not possible to access an element by its index. Sets are used when you need to keep only unique elements within a collection, get rid of duplicates in a sequence, or perform mathematical operations. The Java Collection Framework provides the Set interface to represent a set as an abstract data type. Some commonly used set implementations include HashSet, LinkedHashSet, and TreeSet, which are mutable and have different rules for ordering elements and are optimized for different types of operations. Immutable sets, whose names are not important for programmers, also implement the Set interface.">set</a> of methods, their <a class="theory-lookup" href="/learn/step/10973" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a parameter is a variable that is declared in a method's parentheses and is used within the method to perform a specific task. | When a method is called, values can be passed into the method through these parameters. The parameter list, along with the method's name, determines the method's signature, which is used to distinguish it from other methods in the same class. The order, type, and number of parameters are all important factors in defining a method's parameter list.">parameters</a>, and one or more objects these methods belong to. We <a class="theory-lookup" href="/learn/step/10973" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a call refers to the act of instructing the program to execute a specific set of code within a method. | It involves using the method's name and providing the necessary arguments. The method called (or invoked) depends on the passed parameters. If different values are passed to it, the result of the program will also change. However, when calling a function, you should always provide the correct number and type of arguments that the function expects. For instance, if there is another method that takes a student's name, age, and average score as parameters and prints them, the call to this method will depend on the provided parameters. If the application does not throw an exception, a stack trace message will not be displayed. However, a stack trace can be obtained at any specific point by calling the appropriate method, which will return an array.">call</a> this object <code class="language-java">Receiver</code>. So, an important advantage of decoupling is that if you have to change any of these values, you only have to change one class.</p>
<p>In its classic version, implementing the command pattern involves five steps. Let's see what they are. </p>
<h5 id="the-classic-version">The classic version</h5>
<p>The classic version of the command pattern has the following elements:</p>
<ul>
<li>The<strong> </strong><code class="language-java">Command</code> <a class="theory-lookup" href="/learn/step/3615" rel="noopener noreferrer nofollow" target="_blank" title="In Java, an interface is a reference type that contains method declarations and serves as a literal interface between a class inheriting that interface and another class. | Unlike a class, an interface can extend multiple interfaces, and a class can implement multiple interfaces. Interfaces help to abstract from specific classes and emphasize functionality, making software design more reusable and clean. They cannot be instantiated, and the main idea of an interface is declaring functionality. Interfaces are a special kind of class that represents a map (or dictionary) for storing key-value pairs where the type of the key and the type of the stored value are specified. A real-world example of a map is a phone book where keys are the names of your friends, and values are their phone numbers. The Map interface is not a subtype of the Collection interface, but maps are often considered a collection since they are part of the collection framework and have similar methods.">interface</a> usually declares just a single method for executing the command.</li>
<li>The<strong> </strong><code class="language-java">ConcreteCommand</code> is an <a class="theory-lookup" href="/learn/step/3612" rel="noopener noreferrer nofollow" target="_blank" title="In Java, an operation is a function or method that performs a specific task on data. | In the context of streams, operations are categorized into intermediate and terminal. Intermediate operations, such as filter, map, and distinct, return a new stream and can be chained. Terminal operations, such as forEach and reduce, return a result or side effect and signal the end of the stream pipeline. Additionally, operations can be classified as filtering, mapping/modifying, or reducing/combining, with examples including distinct, sorted, and min. These concepts are essential for processing data effectively with streams in Java.">operation</a> with parameters that pass the call to the receiver; in the classic approach, a command only invokes one or more methods of a <code class="language-java">Receiver</code> rather than performing business logic.</li>
<li>The<strong> </strong><code class="language-java">Receiver</code> performs the action.</li>
<li>The<strong> </strong><code class="language-java">Invoker</code> asks the command to carry out the request.</li>
<li>The<strong> </strong><code class="language-java">Client</code> creates the <code class="language-java">ConcreteCommand</code> object and sets the <code class="language-java">Receiver</code>.</li>
</ul>
<p></p>
<div class="alert alert-primary"> Note that the <code class="language-java">Command</code> interface is not necessarily an interface in terms of language. It can be a simple or an abstract class. The main point is that it represents an abstract command that is inherited by concrete commands. </div>
<p>The following diagram illustrates all the elements of the pattern and how they are related.</p>
<p style="text-align: center;"><picture><img alt="pattern elements" height="311" src="https://ucarecdn.com/2ec87a27-dfe8-4105-8fa6-8705de6f9e53/" width="775"/></picture></p>
<p>The <code class="language-java">Client</code> creates an object of <code class="language-java">Receiver</code> and <code class="language-java">ConcreteCommand</code>, then sets up the <code class="language-java">Invoker</code> to execute the command. Each type of <code class="language-java">ConcreteCommand</code> (<code class="language-java">CreateFileCommand</code>, <code class="language-java">RemoveFileCommand</code>) has a set of fields which represent the parameters. A command calls one or more methods of <code class="language-java">Receiver</code> to execute concrete actions and change the state of the application.</p>
<p>Now let's have a look at a real-world example to understand these concepts better. </p>
<h5 id="example-of-the-command-pattern">Example of the command pattern</h5>
<p>Suppose you are going to build a home automation system where you need to turn the light on and off. Here we have two commands which are quite similar. So first, we will create the <code class="language-java">Command</code> interface. It will have only one method – <code class="language-java">execute()</code>. </p>
<pre><code class="language-java">public interface Command {
    void execute();
}
</code></pre>
<p>Then we will create two classes that will <a class="theory-lookup" href="/learn/step/3556" rel="noopener noreferrer nofollow" target="_blank" title="In Java, an interface is a special type of class that primarily declares functionality. | It contains abstract methods, which are methods without a body, and constants. Interfaces are used to establish a contract for what a class can do, without specifying how the class should do it. This allows for greater flexibility and modularity in programming, as it enables the implementation of multiple inheritances and promotes loose coupling between objects. When a class implements an interface, it agrees to provide the implementation for all the methods declared in the interface.">implement</a> the <code class="language-java">Command</code> interface. These concrete classes encapsulate data needed for the command. So you have to create concrete classes for each command. We will be creating two concrete classes as our application has two commands, <code class="language-java">LightOn</code> and <code class="language-java">LightOff</code>. </p>
<p>First. <code class="language-java">LightOnCommand</code> will implement the <code class="language-java">Command</code> interface. </p>
<pre><code class="language-java">public class LightOnCommand implements Command {

    private Light light;

    public LightOnCommand(Light light) {
        this.light = light;
    }

    @Override
    public void execute() {
        light.lightOn();
    }
}</code></pre>
<p>Next, <code class="language-java">LightOffCommand</code> will implement the <code class="language-java">Command</code> interface. <code class="language-java">LightOffCommand</code> basically has the same code as <code class="language-java">LightOnCommand</code>. </p>
<pre><code class="language-java">public class LightOffCommand implements Command {

    private Light light;

    public LightOffCommand(Light light) {
        this.light = light;
    }

    @Override
    public void execute() {
        light.lightOff();
    }
}</code></pre>
<p>We haven't created the <code class="language-java">Light</code> class yet, which is our <code class="language-java">Receiver</code>. We'll do that next:</p>
<pre><code class="language-java">public class Light {

    public void lightOn() {
        System.out.println("Turn on Light");
    }

    public void lightOff() {
        System.out.println("Turn off Light");
    }
}
</code></pre>
<p>Sometimes learning design patterns with simple examples is difficult because these examples don't represent the complexity of real-world applications. For example, someone may ask, why create a separate <code class="language-java">Light</code> <a class="theory-lookup" href="/learn/step/19918" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a class is one of the fundamental concepts used to develop the logic of a program. | It is a template that defines properties and behaviors of objects. Fields in a class describe the properties of an object, while methods describe what an object can do. Classes can be divided into two groups: instance and static. Instance methods are unique to each instance of a class and can access and modify the state of that instance. Custom classes can be created to define fields and methods that are tailored to specific purposes.">class</a> when we only need two methods and both of them can be implemented on the command classes itself? Well, in a real-world application, the <code class="language-java">Light</code> class can be more complex with more <a class="theory-lookup" href="/learn/step/11523" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a field is a variable that stores data within a class. | It can hold any type of data, including primitive types (such as int, float, boolean) and class types. A class can have multiple fields, and they can have different access modifiers. When a field is declared as static, it belongs to the class itself, rather than to an instance of the class, and shares the same value for all instances. It is a common practice to declare a static field as a global variable to save memory.">fields</a> and methods command classes have nothing to do with.</p>
<p>Next, we need to create the <code class="language-java">Invoker</code><strong> </strong>class. The invoker class decides how the commands are executed. For example, <code class="language-java">Invoker</code> can keep a list of commands that need to be executed in a specific order. Please note that <code class="language-java">Invoker</code> is just a <a class="theory-lookup" href="/learn/step/3535" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a default can refer to a few different concepts. | First, it can refer to the default constructor, which is a no-argument constructor that is automatically provided by the Java compiler if no constructor is explicitly defined in a class. This constructor initializes all fields with their default value. Additionally, in the context of interfaces, default can refer to default methods. Default methods are methods that have a body and the keyword default before their signature in an interface. They provide a default implementation for the method that can be used by classes that implement the interface. This allows for backward compatibility, as new methods can be added to existing interfaces without changing all classes that implement the interface.">default</a> term we use to call the class that decides how commands are executed. You can name it any way you like, depending on the application you're developing.</p>
<p>We will name the invoker class <code class="language-java">Controller</code> here. </p>
<pre><code class="language-java">public class Controller {

    private Command command;

    public void setCommand(Command command) {
        this.command = command;
    }

    public void executeCommand() {
        command.execute();
    }
}</code></pre>
<p>Finally, our client or the <code class="language-java">main</code> method will use the invoker to execute the command. </p>
<pre><code class="language-java">public class HomeAutomationDemo {

    public static void main(String[] args) {

        Controller controller = new Controller();
        Light light = new Light();

        Command lightsOn = new LightOnCommand(light);
        Command lightsOff = new LightOffCommand(light);

        controller.setCommand(lightsOn);
        controller.executeCommand();

        controller.setCommand(lightsOff);
        controller.executeCommand();
    }
}
</code></pre>
<p>What happens here is quite straightforward. There are three significant steps in the main method:</p>
<ol>
<li>Creating an object from the invoker class, which is called <code class="language-java">Controller</code> in our application. </li>
<li>Creating objects from commands that we are going to execute. </li>
<li>Executing commands using invokers. </li>
</ol>
<p>There could be other steps necessary for the completion of these three main steps. For example, the <code class="language-java">main()</code> method has created a <code class="language-java">Light</code> object because a <code class="language-java">Light</code> object has to be passed to create <code class="language-java">Command</code> objects. When you execute this code, the following output will be produced:</p>
<pre><code class="language-java">Turn on Light
Turn off Light</code></pre>
<h5 id="additional-options">Additional options</h5>
<p>The command pattern can also be used for the following purposes:</p>
<ul>
<li>adding commands to a queue to execute them later;</li>
<li>supporting <code class="language-java">undo</code>/<code class="language-java">redo</code> operations;</li>
<li>storing a history of commands;</li>
<li>serializing commands to store them on a disk;</li>
<li>assembling a set of commands into a single composite command known as <strong>macros.</strong></li>
</ul>
<p>These options are not essential to the pattern but are often used in practice.</p>
<p>Sometimes, a command performs all the work by itself instead of invoking the <code class="language-java">Receiver</code> object to do the action. This option is somewhat simpler and also used in practice.</p>
<h5 id="applicability">Applicability</h5>
<p>Possible applications of this pattern include:</p>
<ul>
<li><strong>GUI buttons and menu items. </strong>In Swing programming, an <code class="language-java">Action</code> is a command object. In addition to the ability to perform the desired command, an Action may have an associated icon, a keyboard shortcut, tooltip text, and so on.</li>
</ul>
<ul>
<li><strong>Networking. </strong>It is possible to send whole command objects across the network to be executed on other machines: for example, player actions in computer games.</li>
</ul>
<ul>
<li><strong>Transactional behavior. </strong>Similar to <code class="language-java">undo</code>, a database engine or software installer may keep a list of operations that have been or will be performed. Should one of them fail, all others can be reversed or discarded (this is usually called <strong>rollback</strong>).</li>
</ul>
<ul>
<li><strong>Asynchronous method invocation. </strong>In multithreading programming, this pattern makes it possible to run commands asynchronously in the background of an application. In this case, the <code class="language-java">Invoker</code> is running in the main thread and sends the requests to the <code class="language-java">Receiver</code> which is running in a separate thread. The invoker will keep a queue of commands and send them to the receiver while it finishes running them.</li>
</ul>
<h5 id="conclusion">Conclusion</h5>
<p>The main advantage of the command pattern is that it decouples the object that invokes the operation from the one that knows how to perform it. Various modifications of this pattern can be used to keep a history of requests, implement the undo functionality and create macro commands. However, keep in mind that your application can become more complex because this pattern adds another layer of abstraction instead of simply <a class="theory-lookup" href="/learn/step/10973" rel="noopener noreferrer nofollow" target="_blank" title="In Java, invoking a method refers to the act of executing a method's code by calling it from another part of the program. | When a method is invoked, a new stack frame is created in the program's execution stack to store the method's parameters, local variables, and return address. The method's parameters are passed to the stack frame, and the method's code is executed. Once the method's code has completed execution, the stack frame is removed from the stack, and control is returned to the point in the program from which the method was invoked.">invoking methods</a>.</p>
</div>
