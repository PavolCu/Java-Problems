<h2>Wildcards</h2>
<div class="step-text">
<p>Earlier, when we were discussing type bounds, we mentioned <em><a class="theory-lookup" href="/learn/step/3670" rel="noopener noreferrer nofollow" target="_blank" title="In Java, wildcards are a specific tool used to implement compatibility between different generic objects. | They are represented by the ? sign and are used to indicate that a class, method, or field is compatible with different type parameters. Since generic are type-safe structures, it is impossible to introduce inheritance for generic objects. Wildcards help to address this issue by providing a way to set an upper or lower bound for a generic type, allowing for a certain level of compatibility and flexibility when working with generic objects.">Wildcards</a></em> as a feature that serves a similar purpose and has wide application.</p>
<p>Wildcards are a specific Java tool that allows the implementation of some compatibility between different generic objects. In essence, the wildcard is the "<strong>?"</strong> sign, used to indicate that a class, method, or <a class="theory-lookup" href="/learn/step/11523" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a field is a variable that stores data within a class. | It can hold any type of data, including primitive types (such as int, float, boolean) and class types. A class can have multiple fields, and they can have different access modifiers. When a field is declared as static, it belongs to the class itself, rather than to an instance of the class, and shares the same value for all instances. It is a common practice to declare a static field as a global variable to save memory.">field</a> is compatible with different <a class="theory-lookup" href="/learn/step/3492" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a type parameter is a placeholder for a specific type used in a class or method declaration. | It is defined within angle brackets following the class or method name. Once declared, a type parameter can be used within the class or method body as an ordinary type. The advantage of using type parameters is that they enable you to write more abstract code and develop reusable software libraries. At the time of creating an object of the class or invoking the method, a concrete type is determined for the type parameter.">type parameters</a>.</p>
<h5 id="why-wildcards">Why Wildcards?</h5>
<p>As an <a class="theory-lookup" href="/learn/step/4727" rel="noopener noreferrer nofollow" target="_blank" title="In Java, an object is an instance of a particular class that defines its properties and possible behaviors. | Each object has its own state, separated from other objects, and is accessed using a reference, which stores the memory address where the actual object is located. Objects from the standard library, such as String and Date, as well as programmer-defined classes, are all reference types. The new keyword is used to create an object of a particular class. For example, String str = new String(hello); creates a new String object with the value hello. Objects have a unique identity, can be managed, and have a human-readable representation.">object</a>-oriented language, Java relies on the concept of <a class="theory-lookup" href="/learn/step/3583" rel="noopener noreferrer nofollow" target="_blank" title="In Java, inheritance is a mechanism for deriving a new class from an existing one, known as the superclass, allowing the new class to acquire its fields and methods. | This principle enables code reuse and convenient class hierarchy building. Inheritance is indicated by the keyword extends and supports single inheritance, with a superclass potentially having multiple subclasses. However, constructors are not inherited; instead, the superclass's constructor can be invoked from the subclass's constructor using the super() keyword. This mechanism allows developers to build a class hierarchy that simulates many real-world relationships, such as a general to a particular concept.">inheritance</a>. But since generics are type-safe structures, it is impossible to introduce inheritance for generic objects.</p>
<p>To illustrate this problem, let's consider two classes:</p>
<pre><code class="language-java">class Book {}
class Album extends Book {}</code></pre>
<p>We might assume that a list of albums can be treated as a list of books because <code class="language-java">Album</code> is a subclass of <code class="language-java">Book</code>. But the compiler thinks differently:</p>
<pre><code class="language-java">List&lt;Album&gt; albums = new ArrayList&lt;&gt;();
List&lt;Book&gt; books = albums; // compile-time error</code></pre>
<p>The root of the problem lies in the fact that <code class="language-java">List&lt;Album&gt;</code> is not a <a class="theory-lookup" href="/learn/step/3585" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a subclass is a class that is derived from another class, also known as a superclass or base class. | Subclasses inherit all public and protected fields and methods from their superclass and can also add new fields and methods. A subclass can be referred to using either a subclass reference or a superclass reference, which can refer to any subclass object derived from that superclass. Java does not support multiple-class inheritance, meaning that a class can only inherit from a single superclass, but a superclass can have multiple subclasses.">subclass</a> of <code class="language-java">List&lt;Book&gt;</code>: inheritance does not apply to <a class="theory-lookup" href="/learn/step/3492" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a generic class is a class that is parameterized over a type, allowing it to handle different data types in a uniform manner. | The type parameter is specified within angle brackets following the class name, and it can be used within the class body for fields, method arguments, return values, and local variables. The concrete type is determined when an object of the class is created or a method is invoked. Only reference types, such as arrays, standard classes, or custom classes, can be used as concrete types for generic classes. This approach enables the writing of more abstract and reusable code, as the same class or method can process multiple types in the same way.">generic classes</a>. Such behavior is known as invariance. It doesn't matter that <code class="language-java">Album</code> extends <code class="language-java">Book</code>, because containers like <code class="language-java">List&lt;T&gt;</code>, <code class="language-java">Set&lt;T&gt;</code> and others are treated like independent classes. </p>
<p>The example above is exactly where wildcards could help. A generic class or a method declared with wildcards can avoid inheritance issues. To <a class="theory-lookup" href="/learn/step/3556" rel="noopener noreferrer nofollow" target="_blank" title="In Java, an interface is a special type of class that primarily declares functionality. | It contains abstract methods, which are methods without a body, and constants. Interfaces are used to establish a contract for what a class can do, without specifying how the class should do it. This allows for greater flexibility and modularity in programming, as it enables the implementation of multiple inheritances and promotes loose coupling between objects. When a class implements an interface, it agrees to provide the implementation for all the methods declared in the interface.">implement</a> wildcards, use "?" inside angle brackets (<code class="language-java">&lt;?&gt;</code>). Let's use it to address the compiler error: </p>
<pre><code class="language-java">List&lt;Album&gt; albums = new ArrayList&lt;&gt;();
List&lt;? extends Book&gt; albumsAndBooks = albums; // it is ok</code></pre>
<p>or</p>
<pre><code class="language-java">List&lt;Album&gt; albums = new ArrayList&lt;&gt;();
List&lt;? super Album&gt; albumsAndBooks = albums; // it is ok as well</code></pre>
<p>Wildcards are commonly used with type bounds. In the type bounds article, we learned how to use the <code class="language-java">extends</code> keyword; now we will also take a look at the <code class="language-java">super</code> <a class="theory-lookup" href="/learn/step/3521" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a keyword is a word that has a special meaning in the programming language and is reserved for a specific use. | Keywords cannot be used as variable names in your own program. They have a predefined purpose in the Java language and are used by the Java compiler to parse and understand the code. Examples of keywords include public, class, and void. Understanding keywords is crucial for writing valid Java code and for debugging any syntax errors that may occur.">keyword</a>. Since wildcards are used with type bounding, they can be divided into three groups: <em>unbounded</em> wildcards, <em>upper bounded</em> wildcards, and <em>lower bounded</em> ones.</p>
<h5 id="upper-bounded-wildcards">Upper Bounded Wildcards</h5>
<p>Upper Bounded Wildcards are used when we want to set an upper bound. It is set with the <code class="language-java">extends</code> keyword:</p>
<pre><code class="language-java">? extends ReferenceType</code></pre>
<p>This code can be read as "any type that is a subtype of <code class="language-java">ReferenceType</code>". In other words, if <code class="language-java">S</code> is a subtype of <code class="language-java">T</code>, then type <code class="language-java">List&lt;S&gt;</code> is considered to be a subtype of <code class="language-java">List&lt;? extends T&gt;</code>. This feature is known as covariance.</p>
<p>Suppose that our program represents a library where we want to store only different types of books: normal books, booklets, photo albums, and so on. How would we avoid storing other media types such as audio recordings? Let's say that we have two more classes: </p>
<pre><code class="language-java">public class Booklet extends Book {}
public class AudioFile {}</code></pre>
<p>We can use wildcards to create a list that stores only different types of books: </p>
<pre><code class="language-java">List&lt;? extends Book&gt; storage = new ArrayList&lt;&gt;();

List&lt;Album&gt; albums = new ArrayList&lt;&gt;();
storage = albums; // it works, Album is a subtype of Book

List&lt;Booklet&gt; booklets = new ArrayList&lt;&gt;();
storage = booklets; // it works, Booklet is a subtype of Book

List&lt;AudioFile&gt; recordings = new ArrayList&lt;&gt;();
storage = recordings; // compile-time error, AudioFile is not a subtype of Book</code></pre>
<p>By using an upper-bounded wildcard, we made sure that the storage variable can only be set to subtypes of <code class="language-java">Book</code>.</p>
<p>Now let's consider another limitation of upper bounding.</p>
<pre><code class="language-java">/**
* Hierarchy: Book -&gt; Album
*                 -&gt; Booklet
* Allowed types: List&lt;Book&gt;, List&lt;Album&gt;, List&lt;Booklet&gt;
*/
public void upperBoundedMethod(List&lt;? extends Book&gt; books) {
    Book book = books.get(0); // It is fine

    books.add(new Album()); // compile-time error
    books.add(new Book());  // compile-time error
    books.add(null); // also fine, because null is a special type-independent value
}</code></pre>
<p>Surprisingly, some lines of <code class="language-java">upperBoundedMethod</code> won't compile. Upper bounded wildcards are able to read content as a <code class="language-java">Book</code> type, but they are not able to write any content except for a null value.</p>
<p>Let's explain the logic behind these read and write permissions. Because the method accepts lists parameterized by <code class="language-java">Book</code> or any of its subtypes (<code class="language-java">List&lt;Book&gt;</code>, <code class="language-java">List&lt;Album&gt;</code> or <code class="language-java">List&lt;Booklet&gt;</code>), any argument can be read as an object of type <code class="language-java">Book</code>. Writing to a wildcard argument, however, is prohibited to avoid runtime errors. To see why, suppose that a <code class="language-java">List&lt;Album&gt;</code> was passed in, but then we try to add an instance of <code class="language-java">Book</code> to this list. This <code class="language-java">Book</code> object will be treated as an <code class="language-java">Album</code> object in the future, which will likely lead to a runtime error.</p>
<h5 id="lower-bounded-wildcards">Lower Bounded Wildcards</h5>
<p>Lower bounded Wildcards are introduced with the <code class="language-java">super</code> keyword followed by the lower bound:</p>
<pre><code class="language-java">? super ReferenceType
</code></pre>
<p>This means "any type that is a supertype of <code class="language-java">ReferenceType</code>". For example, if <code class="language-java">S</code> is a supertype of <code class="language-java">T</code>, then <code class="language-java">List&lt;S&gt;</code> is considered to be a supertype of <code class="language-java">List&lt;? super T&gt;</code>. This feature is called contravariance.</p>
<p>Let's think of books again. Now we would like to write code that will enable a list of <code class="language-java">Albums</code> and its <a class="theory-lookup" href="/learn/step/3583" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a superclass is the class from which a subclass is derived. | It is also known as a base class or a parent class. Inheritance is the mechanism by which one class acquires the properties (fields) and behaviors (methods) of another. With inheritance, the subclass inherits all the public and protected fields and methods from the superclass. A subclass can also add new fields and methods, and the inherited and added members will be used in the same way. A superclass serves as a blueprint for the subclass, providing it with inherited fields and methods. A parent class can have multiple child classes, but a child class can only have one parent class due to Java's single inheritance feature. The parent class reference can be used to refer to an object of the subclass. To derive a new class from another, the keyword extends is used. The common syntax is shown below. It is important to note that Java does not support multiple-class inheritance, meaning that a class can only inherit from a single superclass. A class hierarchy can have multiple levels (a class can extend a class that extends a class), and a superclass can have more than one subclass. A subclass inherits all public and protected fields and methods from the superclass.">superclasses</a> to be added to a general <a class="theory-lookup" href="/learn/step/3770" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a library is a collection of pre-written classes and methods that perform specific tasks, which can be used to develop applications more efficiently. | A library, such as the Guava Collection developed by Google, can be utilized when the standard Java collections are not sufficient to solve a problem. For instance, a simple collection can be used in a way similar to a regular array, but it automatically resizes when elements are added or removed, eliminating the need to manually adjust its size. Libraries can also include HTTP clients, which are specialized libraries used to interact over HTTP. They prepare and send HTTP requests to external resources and handle responses. Commonly used HTTP clients in Java include OkHttp, Apache HttpClient, and URLConnection.">library</a>.</p>
<p>Take a look at the following code:</p>
<pre><code class="language-java">List&lt;? super Album&gt; storage = new ArrayList&lt;&gt;();

List&lt;Album&gt; albums = new ArrayList&lt;&gt;();
storage = albums; // it works

List&lt;Book&gt; books = new ArrayList&lt;&gt;();
storage = books; // it works, Book is a supertype for Album

List&lt;Booklet&gt; booklets = new ArrayList&lt;&gt;();
storage = booklets; // compile-time error, Booklet is not a supertype for Album</code></pre>
<p>Here we made sure that only supertypes of the <code class="language-java">Album</code> class can be added to the storage.</p>
<p>Now let's consider some limitations of lower bounding.</p>
<pre><code class="language-java">/**
* Hierarchy: Album &lt;- Book &lt;- Object  
* Allowed types: List&lt;Album&gt;, List&lt;Book&gt;, List&lt;Object&gt;
*/
public void lowerBoundedMethod(List&lt;? super Album&gt; albums) {
    Object object = albums.get(0); // it is ok. Object is upper bound of Album
    Book book = albums.get(0);     // compile-time error
    Album album = albums.get(0);   // compile-time error

    albums.add(new Object()); // compile-time error
    albums.add(new Book());   // compile-time error
    albums.add(new Album());  // OK
    albums.add(null);         // OK, null is type-independent
}</code></pre>
<p>Similarly to upper-bounded wildcards, certain actions involving lower-bounded wildcards lead to compile-time errors. Since any of <code class="language-java">List&lt;Album&gt;</code>, <code class="language-java">List&lt;Book&gt;</code>, <code class="language-java">List&lt;Object&gt;</code> can be passed to <code class="language-java">lowerBoundedMethod</code>, we can't assert that the object being read has the type <code class="language-java">Album</code> or <code class="language-java">Book</code>. We can only be certain that it has type <code class="language-java">Object</code>, since all classes inherit from <code class="language-java">Object</code>.</p>
<p>While <code class="language-java">Object</code> is the only type that can be read from albums, <code class="language-java">Album</code> is the only type that can be added. The reason is that only an instance of <code class="language-java">Album</code> can also be treated as an instance of <code class="language-java">Book</code> and <code class="language-java">Object</code>. If we tried to add an <a class="theory-lookup" href="/learn/step/3549" rel="noopener noreferrer nofollow" target="_blank" title="In Java, an instance refers to an object that is created from a class blueprint. | It represents a specific entity with its own set of attributes and behaviors. For example, in the context of comparing two instances of the class, it means comparing two objects created from the same class but possibly with different values. Instances have access to instance methods, which are methods that belong to each object created from the class. This means that each instance can have its own unique state, and the instance method can access and manipulate this state. To create an instance of a class, you can either call the constructor directly or use the `new` keyword. Additionally, you can obtain an instance of a class by having a reference to a class, such as through an object or a class literal.">instance of</a> <code class="language-java">Book</code>, this instance would be treated as <code class="language-java">Album</code> in the future. The compiler prevents such errors by issuing a compiler-time warning. </p>
<h5 id="get-and-put-principle">Get and Put Principle</h5>
<p>To decide whether extends or super should be used, it is worth remembering the Get and Put principle:</p>
<ul>
<li>
<p>Use upper bounded wildcards when you only get values out of a structure (i.e. when you use only getters or similar methods).</p>
</li>
<li>
<p>Use lower bounded wildcards when you only put values into a structure (i.e. when you use only setters or similar methods). </p>
</li>
<li>
<p>Use Unbounded Wildcards (simply &lt;?&gt;) when you both get and put values (i.e. when you need to use both <a class="theory-lookup" href="/learn/step/3589" rel="noopener noreferrer nofollow" target="_blank" title="In Java, getters and setters are methods used to protect and hide data when creating a class. | A getter method returns the value of a field, while a setter method sets or updates the value. Private fields are hidden from the rest of the code and make public methods more brief and readable. Getters and setters promote data encapsulation, which increases security and control over the data, and promotes a more organized code structure. They can also increase code readability and maintainability by hiding the implementation details of a class from the outside world. Additionally, getters and setters can contain more sophisticated logic, such as returning non-stored values or modifying the value of another field according to a change.">getters and setters</a>).</p>
</li>
</ul>
<p> </p>
<p></p>
<div class="alert alert-primary">Note that putting values may require an extra step to avoid errors â€” we discuss this in the following section.</div>
<p> </p>
<p>To memorize this principle, you can also use PECS: Producer Extends, Consumer Super. This means that if you get a value from a generic class, method, or any other object that produces what you need, you use extends. If you put or set a value into a generic class, method, or any other object that consumes what you put in, you use super.</p>
<p>Remember that it is not possible to put anything into a type declared with the <code class="language-java">extends</code> wildcard except for the null value, which can represent any <a class="theory-lookup" href="/learn/step/4727" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a reference type is a type of variable that stores a reference to an object located elsewhere in memory, rather than storing the object's value directly. | When an object is created using the new operator, it returns a reference to the location of the object in memory, allowing access to its fields and methods. Reference types can be assigned to variables, passed as arguments to methods, and returned as values from methods. They are important for creating complex, object-oriented programs in Java. Unlike primitive types, which store their values directly, reference types store a reference to an object. When comparing reference types using the == operator, it compares the references (memory addresses) rather than the actual values. Additionally, assigning one value of a reference variable to another creates a copy of the reference, rather than the value itself. Reference types can also refer to a special value that represents the fact that it is not initialized yet or does not have a value. It is important to note that in Java, the heap is the region of memory where objects are stored and allocated dynamically during runtime.">reference type</a>. Similarly, it is not possible to retrieve anything from a type declared with the super wildcard except for an instance of <code class="language-java">Object</code>, the parent of every reference type.</p>
<p> </p>
<p></p>
<div class="alert alert-warning"> You cannot use both a lower and an <a class="theory-lookup" href="/learn/step/8216" rel="noopener noreferrer nofollow" target="_blank" title="In Java, an upper bound is a feature used to set a maximum limit for a type in a generic context. | It is set with the extends keyword and indicates that a type must be a subtype of the specified type or implement the specified interface. This is useful when you want to restrict the types that can be used with a generic class or method. For example, if you have a library that stores different types of books, you can use an upper bound to ensure that only book-related types are stored, such as NormalBook and Booklet, and not other medium types like AudioRecording.">upper bound</a> in wildcards or type bounds.</div>
<p> </p>
<p>Note that a class or <a class="theory-lookup" href="/learn/step/3615" rel="noopener noreferrer nofollow" target="_blank" title="In Java, an interface is a reference type that contains method declarations and serves as a literal interface between a class inheriting that interface and another class. | Unlike a class, an interface can extend multiple interfaces, and a class can implement multiple interfaces. Interfaces help to abstract from specific classes and emphasize functionality, making software design more reusable and clean. They cannot be instantiated, and the main idea of an interface is declaring functionality. Interfaces are a special kind of class that represents a map (or dictionary) for storing key-value pairs where the type of the key and the type of the stored value are specified. A real-world example of a map is a phone book where keys are the names of your friends, and values are their phone numbers. The Map interface is not a subtype of the Collection interface, but maps are often considered a collection since they are part of the collection framework and have similar methods.">interface</a> used with the <code class="language-java">extends</code> or <code class="language-java">super</code> keyword is itself included in the inheritance. For example, <code class="language-java">Box&lt;T&gt;</code> is compatible and covariant with <code class="language-java">Box&lt;? extends T&gt;</code> and <code class="language-java">Box&lt;? super T&gt;</code>.</p>
<p>Also note that the unbounded wildcard <code class="language-java">?</code> is equivalent to <code class="language-java">? extends Object</code>.</p>
<p> </p>
<p></p>
<div class="alert alert-primary"> Remember that the purpose of inheritance prohibition in generics is to prevent run-time errors; otherwise, generics would lose their type safety.</div>
<p> </p>
<h5 id="wildcard-capture">Wildcard capture</h5>
<p>Let's consider the example:</p>
<pre><code class="language-java">public static void reverse(List&lt;?&gt; list) {
  List&lt;Object&gt; tmp = new ArrayList&lt;Object&gt;(list);
  for (int i = 0; i &lt; list.size(); i++) {
    list.set(i, tmp.get(list.size() - i - 1)); // compile-time error
  }
}</code></pre>
<p>What causes the <a class="theory-lookup" href="/learn/step/3536" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a compile-time error is a type of error that prevents a Java program from being compiled due to issues such as syntax errors, incorrect keyword usage, missing symbols, improper source code file names, invocation of non-existing methods, and other issues. | These errors are different from run-time errors, which occur during the execution of a program. Compile-time errors are typically easier to identify and fix because they prevent the program from compiling, while run-time errors may not be discovered until the program is running.">compile-time error</a>? Recall that <code class="language-java">&lt;?&gt; </code>is equivalent to <code class="language-java">&lt;? extends Object&gt;</code>. The compiler signals an error because it does not know the type of object being written to the list. The scenario is known as the <a class="theory-lookup" href="/learn/step/10088" rel="noopener noreferrer nofollow" target="_blank" title="In Java, wildcard capture refers to the process of determining the actual type argument of a generic class or method that uses a wildcard as its type parameter during runtime. | Wildcards are denoted by the ? symbol and are used when the specific type is unknown or unimportant. Wildcard capture is crucial in Java's type system as it enables the use of generic types in a flexible and type-safe manner. It is particularly useful in situations where inheritance is not possible or desirable, allowing for greater compatibility between different generic objects.">wildcard capture</a> problem and can be solved by the trick:</p>
<pre><code class="language-java">public static void reverse(List&lt;?&gt; list) { 
  reverseCaptured(list); 
}

private static &lt;T&gt; void reverseCaptured(List&lt;T&gt; list) {
  List&lt;T&gt; tmp = new ArrayList&lt;T&gt;(list);
  for (int i = 0; i &lt; list.size(); i++) {
    list.set(i, tmp.get(list.size() - i - 1));
  }
}</code></pre>
<p>Here we introduced a helper method <code class="language-java">reverseCaptured</code> which has a parameter of a certain type <code class="language-java">T</code> for all elements of a list. The method is error-free because it is merely a <a class="theory-lookup" href="/learn/step/3606" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a generic method is a method that introduces its own type parameters, which can be used to declare the return type and the types of the method's parameters. | A generic method is not restricted by wildcards, which are used to implement an equivalent of inheritance in generics. Wildcards are declared with the '?' symbol and are often used with upper or lower bounds to restrict the type parameter. A generic method can take or return values of non-generic types as well. For example, a generic method can take a generic array and return its size as an integer. A generic method's body is declared like that of any other method. A generic method can be called with any reference type as an argument, such as an array of integers or an array of strings.">generic method</a>; it does not face any restrictions due to wildcards.</p>
<h5 id="conclusion">Conclusion</h5>
<p>Wildcards are a convenient and safe way of implementing an equivalent of inheritance in Generics. They are declared with the <code class="language-java">&lt;?&gt;</code> symbol and are widely used with upper or lower bounds to restrict type parameters.</p>
</div>
